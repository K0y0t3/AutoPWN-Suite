from os.path import exists
from os import mkdir
from dataclasses import dataclass

from requests import get
from requests.exceptions import JSONDecodeError
from rich.console import Console

from modules.random_user_agent import random_user_agent
from modules.logger import Logger, banner


log = Logger()


@dataclass
class ExploitInfo:
    Platform : str
    PublishDate : str
    Type : str
    ExploitDBID : int
    Author : str
    Metasploit : bool
    Verified : bool
    Link : str


def GetExploitInfo(CVEID):
    try:
        user_agent = next(random_user_agent())
        apiresponse = get(
            f"https://www.exploit-db.com/search?cve={CVEID}",
            headers={
                "X-Requested-With": "XMLHttpRequest",
                "User-Agent": user_agent
            }
        )
    except ConnectionError:
        log.logger(
            "error",
            "Connection error raised while trying"
            + f" to fetch information about: {CVEID}"
        )
        return []
    else:
        try:
            apidata = apiresponse.json()
        except JSONDecodeError:
            log.logger(
                "error", "An error occured while "
                + "trying to decode JSON received from "
                + f"previous request for {CVEID} with "
                + f"user agent {user_agent}"
            )
            return []
        ExploitInfos = []
        for exploit in apidata['data']:
            Exploit = ExploitInfo(
                Platform=exploit['platform_id'],
                PublishDate=exploit['date_published'],
                Type=exploit['type_id'],
                ExploitDBID=int(exploit['id']),
                Author=exploit['author']['name'],
                Metasploit=exploit['author']['name'] == "Metasploit",
                Verified=exploit['verified'] == "1",
                Link=f"https://www.exploit-db.com/download/{exploit['id']}"
            )
            ExploitInfos.append(Exploit)

        return ExploitInfos


def GetExploitContents(ExploitID):
    try:
        user_agent = next(random_user_agent())
        apiresponse = get(
            f"https://www.exploit-db.com/download/{ExploitID}",
            headers={
                "X-Requested-With": "XMLHttpRequest",
                "User-Agent": user_agent
            }
        )
        content = apiresponse.content
        try:
            filename = apiresponse.headers['Content-Disposition'].lstrip(
                    "attachment; filename=\""
                )
        except KeyError:
            log.logger(
                "error",
                f"Could not get filename, {ExploitID}.exp will be used."
                )
            print(user_agent)
            filename = f"{ExploitID}.exp"
    except ConnectionError:
        log.logger(
            "error",
            f"Connection error raised while trying to fetch: {ExploitLink}"
        )
        return None, None
    else:
        return content, filename


def GetExploitAsFile(vulnerability, term_width):
    console = Console()

    SoftwareName = vulnerability.Software
    CVEs = vulnerability.CVEs

    if not exists("exploits"):
        mkdir("exploits")

    printed_software = []
    for CVE in CVEs:
        Exploits = GetExploitInfo(CVE)
        if len(Exploits) < 0:
            continue


        for exploit in Exploits:
            if SoftwareName not in printed_software: # i moved this here so software doesnt get printed if not exploits found for it
                console.print(f"\n\n┌─[yellow][{SoftwareName}][/yellow]\n│")
                printed_software.append(SoftwareName)
            print(
                f"Downloading exploit(s) for {SoftwareName} ({CVE})...",
                end="\r"
            )
            content, filename = GetExploitContents(exploit.ExploitDBID)
            if content is None:
                continue

            if not exists(f"exploits/{SoftwareName}"):
                mkdir(f"exploits/{SoftwareName}")

            if not exists(f"exploits/{SoftwareName}/{CVE}"):
                mkdir(f"exploits/{SoftwareName}/{CVE}")

            with open(
                    f"exploits/{SoftwareName}/{CVE}/{filename}", "wb"
                ) as exploitfile:
                print(" " * term_width, end="\r") #clear the line
                console.print(f"│\n├─────┤ [red]{str(CVE)}[/red]\n│") # i moved this here so vulnerabilities without exploits dont get printed
                console.print(
                    f"├──────────# exploits/{SoftwareName}/{CVE}/{filename}\n"
                    + f"│\t\t [cyan]Platform: [/cyan] {exploit.Platform}\n"
                    + f"│\t\t [cyan]Type: [/cyan] {exploit.Type}\n"
                    + f"│\t\t [cyan]Author: [/cyan] {exploit.Author}\n"
                    + f"│\t\t [cyan]Date: [/cyan] {exploit.PublishDate}\n"
                    + f"│\t\t [cyan]Metasploit: [/cyan] {exploit.Metasploit}\n"
                    + f"│\t\t [cyan]Verified: [/cyan]{exploit.Verified}\n"
                    + f"│\t\t [cyan]Link: [/cyan] {exploit.Link}\n│"
                )
                exploitfile.write(content)

    if SoftwareName in printed_software:
        print("└" + "─" * (term_width-1) + "\n")


def GetExploitsFromArray(VulnsArray, term_width, target=None):
    console = Console()

    if target:
        banner(f"Downloading exploits for {target}...", "blue")
    else:
        banner(f"Downloading exploits...", "blue")

    for vulnerability in VulnsArray:
        GetExploitAsFile(vulnerability, term_width)
